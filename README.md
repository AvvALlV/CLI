# CLI

Авторы:
- Шакиров Игорь
- Чучин Дмитрий

# Краткое описание работы CLI

Основной класс **Interpreter**, он запускает интерпретатор и ждет, пока пользователь введет команду.<br>
Затем входной поток передаётся **Preprocessor**, который при необходимости заменяет любые вхождения переменных, обозначенных символом «$», соответствующими значениями.<br>
Полученная обработанная строка передаётся **Lexer**, который разбивает ее на токены в виде односвязного списка и предоставляет их в качестве итератора с помощью команды NextToken() (итератором выступает сам лексер). <br>
Полученный Lexer передается в качестве аргумента конструктора классу **Parser**, который проходится по токенам и инициализирует список команд **Command** в виде массива. Поскольку команды в shell выполняются последовательно, соседние элементы массива соединяются с помощью механизма Pipeline.<br>
Полученный массив команд затем передается **Executor**, который исполняет команды.<br>
Сами комманды **CommandBase** принимают список аргументов, поток ввода и поток вывода. Executor гарантирует, что поток вывода одной команды станет потоком ввода следующей команды. Сами команды используют как список аргументов, так и поток ввода.<br>
Результатом Executor является выходной поток и логическое значение, указывающее, следует ли выйти из интерпретатора. Класс Interpreter получает этот результат и ожидает следующей команды, если команды выхода не было.

# Диаграмма классов

![Class Diagramm](./public/ClassDiagram.png)

### Preprocessor
Препроцессор обрабатывает строку посимвольно следующим образом:
* если очередной символ не $, ' или ", то он проигнорируется препроцессором;
* если очередной символ $, то: 
  * препроцессор жадно попытается прочитать полное имя переменной, пока не встретит символ, которого не может быть в имени переменной ([подробнее про имена](https://www.gnu.org/software/bash/manual/html_node/Definitions.html#index-name));
  * если имя есть в **ContextProvider**, то вместо символа $ и имени переменной подставится строковое значение из контекста, иначе пустая строка
* если очередной символ ', то пока не будет встречено ' препроцессор будет игнорировать символы " и $;
* если очередной символ ", то пока не будет встречено " препроцессор будет игнорировать символ '.

### Parser
Парсер итерируется по лексемам, которые создал **Lexer**. Он отделяет лексемы каждой из 
команд пайпа друг от друга по символу |. Каждый массив лексем, который относится 
к одной команде парсер передает в **CommandFactory**, чтобы получить объект **Command**.
Объекты **Command** парсер объединяет в массив, который задает pipe.

### CommandFactory
**CommandFactory** из переданного массива лексем выделяет имя команды, которое записано первым элементом
и определяет какую именно команду ему нужно создать, после чего создает команду. 
В конструктор передаются оставшиеся лексемы в качестве аргументов.

# Диаграмма последовательности

![Sequence diagram](./public/SequenceDiagram.png)